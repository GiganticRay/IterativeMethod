#include "IterativeSolver.h"
#include "SerialBLAS.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>			// memset, memcpy

#include <cmath>			// std::abs

using namespace std;

#define MIN_VALUE 1e-8
#define IS_DOUBLE_ZERO(d)  (std::abs(d) < MIN_VALUE)

void GMRES_Solver(double res_thres, int iter_times_thres, double& res, int & iter_times, cs* A, double* b){

	iter_times = 0;

	/* auxiliary params
		Q[M][N]
		H[N][N]
		dim:	dimension of final Krylov subspace
		vec*:	calculate next q
	*/
	double** Q;
	double** H;
	int dim = 0;
	double* vec;

	int M = A->m;
	int N = A->n;

	vec = (double*) malloc (M * sizeof(double));

	// column major order since we'd like always access column of Q
	// so access Q[i][j] logically is Q[j][i]
	Q = (double**) malloc (N * sizeof(double*));
	for( int i = 0; i < N; i++){
		Q[i] = (double*) malloc (M * sizeof(double));
	}

	// column major order
	H = (double**) malloc (N *sizeof(double*));
	for( int i = 0; i < N; i++){
		H[i] = (double*) malloc ( N * sizeof(double));
	}

	printf("Coefficient matrix is :");
	cs_print(A, 1);

	// GMRES
	// q1
	s_norm(M, b, 2);
	s_axpby(M, 1 / s_norm(M, b, 2), b, 1, NULL, Q[0]);

	for(int n = 0; n < N && iter_times < iter_times_thres; n++){
		// v = Aqn
		memset(vec, 0, sizeof(int) * M);
		cs_gaxpy(A, Q[n], vec);
		// subtract every components of v which are generated by project v into every orthogonal basis: Q[0: n]
		for(int j = 0; j <= n; j++){
			H[n][j]	= s_inner_prod(M, Q[j], vec);
			s_axpby(M, 1.0, vec, -1.0 * H[n][j], Q[j], vec);
		}
		double H_np1_n = s_norm(M, vec, 2);
		if(IS_DOUBLE_ZERO(H_np1_n)){
			break;
		}
		H[n][n+1] = H_np1_n;
		memcpy(Q[n+1], vec, sizeof(double) * M);

		dim ++;
		s_axpby(M, 1 / H[n][n+1], Q[n+1], 1, NULL, Q[n+1]);

		// solving Ax=b where A is hessenberg matrix form
		// set res and compare the residual with res_thres
	}

}